@page "/fileupload"

@using Client.Services;
@using global::Shared.Entities;
@using global::Shared.Dtos;
@implements IAsyncDisposable;
@inject IJSRuntime JSRuntime;
@inject ISubjectService SubjectService;
@inject IGradeService GradeService;

<h3>Upload your code as a file!</h3>

<div @ref="fileDropContainer" class="file-drop-zone @HoverClass" @ondragenter="OnDragEnter" @ondragleave="OnDragLeave" @ondragover="OnDragEnter">
    <InputFile OnChange="@OnChange"  multiple/>
</div>

<select class="form-control" @bind="@selectedSubject">

        @foreach (var item in @SubjectService.Subjects)
        {
            <option value="@item.Id"> @item.Name </option>
        }
</select>

<select class="form-control" @>

</select>

<div class="error-message-container">
    <p>@ErrorMessage</p>
</div>

<div>
    <button type="submit" @onclick="AddGradeKeyAsync">
        Add
    </button>
</div>

<EditForm Model="@stringCode">
    <InputTextArea @bind-Value="stringCode" readonly style="will-change: auto;"/>
</EditForm>

@code 
{
    private int selectedSubject;
    private string HoverClass = string.Empty;
    void OnDragEnter(DragEventArgs e) => HoverClass = "hover";
    void OnDragLeave(DragEventArgs e) => HoverClass = string.Empty;
    IJSObjectReference? _filePasteModule = default(IJSObjectReference);
    IJSObjectReference? _filePasteFunctionReference = default(IJSObjectReference);
    ElementReference fileDropContainer;
    IBrowserFile? file;
    ScriptType scriptType; 
    string stringCode = string.Empty;
    private string ErrorMessage = string.Empty;
    private const int maxAllowedFiles = 1;
    private int _userId = 1;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            await GradeService.GetAllKindsAsync();
            await SubjectService.GetSubjectsByTeacherAsync(_userId);
        }

        catch(Exception e)
        {
            throw;
        }
    }
    private async Task AddGradeKeyAsync()
    {
        if(stringCode == string.Empty)
        {
            ErrorMessage = "Script is needed!";
        }

        var kinds = GradeService.Kinds.Select(k => new GradeKindPostDto { Name = k.Name }).ToList();
        await GradeService.CreateGradeKeyAsync(
            new GradeKeyPostDto 
            { 
                Name = "test_lua", 
                UsedKinds = kinds,
                TeacherId = _userId, 
                SubjectId = selectedSubject, 
                ScriptType = scriptType, 
                Calculation = stringCode 
            });
    }
    public async ValueTask DisposeAsync()
    {
        if (_filePasteFunctionReference != null)
        {
            await _filePasteFunctionReference.InvokeVoidAsync("dispose");
            await _filePasteFunctionReference.DisposeAsync();
        }
        if (_filePasteModule != null)
        {
            await _filePasteModule.DisposeAsync();
        }
    }

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {   
        if(firstRender)
        {
            _filePasteModule = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/filePaste.js");
            _filePasteFunctionReference = await _filePasteModule.InvokeAsync<IJSObjectReference>("initializeFilePaste", fileDropContainer, file);
        }
    }
    
    async Task OnChange(InputFileChangeEventArgs e)
    {
        stringCode = string.Empty;
        ErrorMessage = string.Empty;

        using var content = new MultipartFormDataContent();

        if (e.FileCount > maxAllowedFiles)
        {
            ErrorMessage = $"Only {maxAllowedFiles} files can be uploaded";
            return;
        }

        
        foreach (var file in e.GetMultipleFiles())
        {
            var isAllowed = false;
            var fileContent = new StreamContent(file.OpenReadStream());

            switch (Path.GetExtension(file.Name))  
            {
                case ".lua":
                    scriptType = ScriptType.Lua; 
                    isAllowed = true;
                    break;
                case "py":
                    scriptType = ScriptType.Python;
                    isAllowed = true;
                    break;
                case "csc":
                    scriptType = ScriptType.CSharpScript;
                    isAllowed = true;
                    break;
                case "js":
                    isAllowed = true;
                    scriptType = ScriptType.JavaScript;
                    break;
                default:
                    ErrorMessage = "Content Type not sopported";
                    break;
            }

            if (isAllowed)
            {
                stringCode = await fileContent.ReadAsStringAsync();
            }
            
        }
    }    
}


